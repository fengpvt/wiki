# 《深入理解Java虚拟机》阅读笔记

[toc]

## 一、走进Java

### 1.1 走进Java

## 二、自动内存管理

### 2.1 Java内存区域与内存溢出

运行时数据区域
1. 程序计数器
2. Java虚拟机栈
3. 本地方法栈
4. Java堆
5. 方法区

其中，Java堆和方法区两个数据区域由所有线程共享。

#### 程序计数器
当前线程所执行的字节码的行号指示器
由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现，在任何一个确定的时刻，一个处理器都只会执行一个线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。

#### Java虚拟机栈
Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数帧、动态连接、方法出口等信息。每一个方法被调用直至完毕的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
针对局部变量表：存放编译器可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用、returnAddress类型。

#### 本地方法栈
作用类似Java虚拟机栈，但是是为了虚拟机使用到Native方法服务。
HotSpot虚拟机直接把本地方法栈和Java虚拟机栈合二为一

#### Java堆
所有的对象实例以及数组都应当在堆上分配。Java堆可以处于物理上不连续的内存空间中，但在逻辑上应当被视为连续的。

#### 方法区
用于存储已被虚拟机加载的类信息、常量、静态变量、JIT编译器编译后的代码缓存等数据。
在JDK7之前，Hotspot中方法区的实现是永久代（Perm）
在JDK7上，HotSpot将原本在永久代中的常量池、静态变量等移除
在JDK8上，HotSpot废弃永久代的概念，改用在本地内存中实现的元空间（Metaspace）来代替，主要存放类信息。

### 2.2 垃圾收集器与内存分配策略

#### 引用计数法
主流的Java虚拟机都没有使用该算法来管理内存，存在互相引用导致无法回收的情况

#### 可达性分析算法
通过一系列GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程锁走过的路径称为“引用链”，如果对象到GC Roots之间没有任何引用链相连，证明该对象不在被使用。

固定可作为GC Roots的对象包括一下几种：
1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI引用的对象
5. Java虚拟机内部的引用
6. 所有被同步锁（synchronized）持有的对象
7. 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

#### 引用


### 2.3 虚拟机性能监控、故障处理工具

### 2.4 调优案例分析与实战

## 三、虚拟机执行子系统

### 3.1 类文件结构

### 3.2 虚拟机类加载机制

### 3.3 虚拟机字节码执行引擎

### 3.4 类加载及执行子系统的案例与实战

## 四、程序编译与代码优化

### 4.1 前端编译与优化

### 4.2 后端编译与优化

## 五、高效并发

### 5.1 Java内存模型与线程

### 5.2 线程安全与锁优化